<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>æ‰‹æœºå·åŒ¹é…æå– </title>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    function cleanPhone(v){ if(v==null) return ""; return String(v).replace(/\D+/g, ""); }

    function detectDelimiter(sampleText){
      const comma = (sampleText.match(/,/g)||[]).length;
      const tab = (sampleText.match(/\t/g)||[]).length;
      if (tab > comma) return "\t";
      return ",";
    }

    function readAsText(file){
      return new Promise((resolve, reject)=>{
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.onerror = reject;
        fr.readAsText(file, 'utf-8');
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      const el = (id)=> document.getElementById(id);
      const csvInput = el('csvFiles');
      const txtInput = el('txtFiles');
      const parseBtn = el('parseBtn');
      const downloadBtn = el('downloadBtn');
      const resultInfo = el('resultInfo');
      const previewBox = el('previewBox');

      // æ–°å¢ï¼šå·æ®µç­›é€‰ç›¸å…³å…ƒç´ 
      const segmentInput = el('segmentInput');
      const segmentFileInput = el('segmentFile');
      const segmentBtn = el('segmentBtn');
      const downloadSegBtn = el('downloadSegBtn');
      const downloadRemainBtn = el('downloadRemainBtn');
      const segmentInfo = el('segmentInfo');

      let csvPhonesSet = new Set();
      let txtRows = [];
      let matchedRows = [];

      async function handleCSV(){
        csvPhonesSet.clear();
        if(!csvInput.files?.length){ return; }
        for(const file of csvInput.files){
          const text = await readAsText(file);
          const parsed = Papa.parse(text, { header:true, skipEmptyLines:true });
          const headers = parsed.meta.fields;
          const phoneCol = headers.find(h=> h.includes("æ‰‹æœºå·")||h.toLowerCase().includes("phone")) || headers[0];
          parsed.data.forEach(row=>{
            const ph = cleanPhone(row[phoneCol]);
            if(ph) csvPhonesSet.add(ph);
          });
        }
        resultInfo.textContent = `å·²åŠ è½½ ${csvInput.files.length} ä¸ª CSVï¼Œå…±æå– ${csvPhonesSet.size} ä¸ªæ‰‹æœºå·`;
      }

      async function handleTXT(){
        txtRows = [];
        if(!txtInput.files?.length){ return; }
        for(const file of txtInput.files){
          const text = await readAsText(file);
          const delim = detectDelimiter(text.slice(0,2000));
          const parsed = Papa.parse(text, { header:false, delimiter:delim, skipEmptyLines:true });
          parsed.data.forEach(r=> txtRows.push(r));
        }
        resultInfo.textContent = `å·²åŠ è½½ ${txtInput.files.length} ä¸ª TXTï¼Œæ€»è¡Œæ•° ${txtRows.length}`;
      }

      parseBtn.addEventListener('click', ()=>{
        matchedRows = [];
        txtRows.forEach(row=>{
          const phone = cleanPhone(row[0]);
          if(csvPhonesSet.has(phone)){
            matchedRows.push(row);
          }
        });
        const lines = matchedRows.map(r=> r.join(","));
        const blob = new Blob([lines.join("\n")], { type:'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        downloadBtn.href = url;
        downloadBtn.download = `matched_phone_data_${Date.now()}.txt`;
        downloadBtn.classList.remove('disabled');
        resultInfo.textContent = `åŒ¹é…å®Œæˆï¼š${matchedRows.length} è¡Œ`;        
        previewBox.value = lines.slice(0,50).join("\n");
      });

      csvInput.addEventListener('change', handleCSV);
      txtInput.addEventListener('change', handleTXT);

      // å·æ®µç­›é€‰åŠŸèƒ½
      segmentBtn.addEventListener('click', async ()=>{
        if(!segmentFileInput.files?.length){ alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªTXTæ–‡ä»¶'); return; }
        const file = segmentFileInput.files[0];
        const text = await readAsText(file);
        const delim = detectDelimiter(text.slice(0,2000));
        const parsed = Papa.parse(text, { header:false, delimiter:delim, skipEmptyLines:true });
        const rows = parsed.data;
        const seg = segmentInput.value.trim();
        if(!seg){ alert('è¯·è¾“å…¥å·æ®µ'); return; }

        let matched = [];
        let remain = [];
        rows.forEach(r=>{
          const ph = cleanPhone(r[0]);
          if(ph.startsWith(seg)) matched.push(r); else remain.push(r);
        });

        const matchedLines = matched.map(r=> r.join(","));
        const remainLines = remain.map(r=> r.join(","));

        const blob1 = new Blob([matchedLines.join("\n")], { type:'text/plain;charset=utf-8' });
        const blob2 = new Blob([remainLines.join("\n")], { type:'text/plain;charset=utf-8' });

        downloadSegBtn.href = URL.createObjectURL(blob1);
        downloadSegBtn.download = `segment_${seg}_${matched.length}_${Date.now()}.txt`;
        downloadSegBtn.textContent = `ä¸‹è½½å·æ®µç»“æœ (${matched.length} è¡Œ)`;
        downloadSegBtn.classList.remove('disabled');

        downloadRemainBtn.href = URL.createObjectURL(blob2);
        downloadRemainBtn.download = `remain_except_${seg}_${remain.length}_${Date.now()}.txt`;
        downloadRemainBtn.textContent = `ä¸‹è½½å‰©ä½™å·ç  (${remain.length} è¡Œ)`;
        downloadRemainBtn.classList.remove('disabled');

        segmentInfo.textContent = `ç­›é€‰å®Œæˆï¼šå·æ®µ ${seg} â†’ ${matched.length} è¡Œï¼›å‰©ä½™ ${remain.length} è¡Œ`;
      });
    });
  </script>
  <style>
    body{font-family:sans-serif;max-width:900px;margin:20px auto;padding:0 15px;}
    .card{border:1px solid #ddd;border-radius:8px;padding:16px;margin:12px 0;}
    .btn{padding:10px 16px;background:#1a73e8;color:#fff;border:none;border-radius:6px;cursor:pointer;margin-right:10px;}
    .btn.disabled{opacity:.5;pointer-events:none;}
    textarea{width:100%;height:200px;margin-top:10px;}
  </style>
</head>
<body>
  <h1>ğŸ“± ä¼šå‘è´¢---æ‰‹æœºå·åŒ¹é…æå–å·¥å…·</h1>
  <div class="card">
    <h3>â‘  é€‰æ‹©ä¸€ä¸ªæˆ–å¤šä¸ª CSV æ–‡ä»¶ (å«æ‰‹æœºå·)</h3>
    <input id="csvFiles" type="file" accept=".csv,.txt" multiple />
  </div>
  <div class="card">
    <h3>â‘¡ é€‰æ‹©ä¸€ä¸ªæˆ–å¤šä¸ª TXT æ–‡ä»¶ (æ•°æ®æº)</h3>
    <input id="txtFiles" type="file" accept=".txt,.csv" multiple />
  </div>
  <div class="card">
    <button id="parseBtn" class="btn">â‘¢ å¼€å§‹åŒ¹é…</button>
    <a id="downloadBtn" class="btn disabled" href="#">ä¸‹è½½ç»“æœ TXT</a>
    <p id="resultInfo"></p>
    <textarea id="previewBox" placeholder="ç»“æœé¢„è§ˆ (å‰50è¡Œ)"></textarea>
  </div>

  <div class="card">
    <h3>â‘£ å·æ®µç­›é€‰åŠŸèƒ½</h3>
    <p>ä¸Šä¼ ä¸€ä¸ª TXT æ–‡ä»¶ï¼Œå¹¶è¾“å…¥è¦ç­›é€‰çš„å·æ®µï¼Œä¾‹å¦‚ <b>255</b>ï¼š</p>
    <input id="segmentFile" type="file" accept=".txt,.csv" />
    <input id="segmentInput" type="text" placeholder="è¾“å…¥å·æ®µ (å¦‚ 255)" />
    <button id="segmentBtn" class="btn">ç­›é€‰å·æ®µ</button>
    <a id="downloadSegBtn" class="btn disabled" href="#">ä¸‹è½½å·æ®µç»“æœ</a>
    <a id="downloadRemainBtn" class="btn disabled" href="#">ä¸‹è½½å‰©ä½™å·ç </a>
    <p id="segmentInfo"></p>
  </div>
</body>
</html>
